#!/usr/bin/env python3
"""
https://www.rdkit.org/docs/source/rdkit.Chem.Scaffolds.MurckoScaffold.html
https://www.rdkit.org/docs/source/rdkit.Chem.Scaffolds.rdScaffoldNetwork.html
rdScaffoldNetwork available RDKit 2020.03.1+.

https://matplotlib.org/
https://pyvis.readthedocs.io/en/latest/
"""
import csv
import inspect
import json
import logging
import os
import queue
import re
import sys
import tempfile
from typing import Optional

import pandas as pd
import pyvis
import rdkit
import rdkit.Chem
import rdkit.Chem.AllChem
import rdkit.Chem.rdmolops

# fingerprints:
from rdkit.Chem import MolFromSmiles, MolToSmiles, PandasTools, rdRGroupDecomposition
from rdkit.Chem.AllChem import Compute2DCoords

# scaffolds:
from rdkit.Chem.Scaffolds import MurckoScaffold, rdScaffoldNetwork
from rdkit.Chem.Scaffolds.rdScaffoldNetwork import EdgeType, NetworkEdge

from .. import util


def get_csv_writer(file_path: str, delimiter: str):
    if file_path is sys.stdout:
        f = file_path
    else:
        f = open(file_path, "w")
    csv_writer = csv.writer(f, delimiter=delimiter)
    return csv_writer, f


def close_file(f):
    if f is not sys.stdout:
        f.close()


def ensure_path_separator(dir: str):
    """
    Ensure that given path is a directory by appending
    '/' or whatever path separator is appropriate.

    :param str dir: path to directory
    :return _type_: dir with path separator appended (will be same as dir if separator already present)
    """
    return os.path.join(dir, "")


def fix_pyvis_header_html(html_file_path: str):
    """
    Fix issue with double-heading in pyvis-generated HTML file.
    :param str html_file_path: path to HTML file
    """
    with open(html_file_path, "r+") as f:
        html_txt = f.read()
        html_rev = re.sub(r"<center>.+?<\/h1>\s+<\/center>", "", html_txt, 1, re.DOTALL)
        f.seek(0)
        f.write(html_rev)
        f.truncate()


def center_align_pyvis_html(html_file_path: str):
    """
    Center pyvis-generated graph in HTML file (rather than left-align).
    :param str html_file_path: path to HTML file
    """
    # Open the HTML file, add a CSS rule to center the graph, and save the changes.
    with open(html_file_path, "r+") as f:
        html_txt = f.read()
        html_txt = html_txt.replace("float: left;", "margin: auto;")
        f.seek(0)
        f.write(html_txt)
        f.truncate()


def write_scaffold_net(
    scafnet, ofile: str, odelimeter: str = ",", oheader: bool = False
):
    net_writer, f = get_csv_writer(ofile, odelimeter)
    if oheader:
        net_writer.writerow(["element_type", "index", "info"])
    for i in range(len(scafnet.nodes)):
        info = {
            "SMILES": scafnet.nodes[i],
            "Counts": scafnet.counts[i],
        }
        net_writer.writerow(["node", i, json.dumps(info)])
    for i in range(len(scafnet.edges)):
        info = {
            "beginIdx": scafnet.edges[i].beginIdx,
            "endIdx": scafnet.edges[i].endIdx,
            "edgeType": str(scafnet.edges[i].type),
        }
        net_writer.writerow(
            [
                "edge",
                i,
                json.dumps(info),
            ]
        )
    close_file(f)


#############################################################################
def Mols2BMScaffolds(mols, molWriter):
    scafmols = []
    legends = []
    for i, mol in enumerate(mols):
        molname = mol.GetProp("_Name") if mol.HasProp("_Name") else ""
        logging.debug(f"{i+1}. {molname}")
        scafmol = MurckoScaffold.GetScaffoldForMol(mol)
        Compute2DCoords(scafmol, clearConfs=True)
        scafmols.append(scafmol)
        legends.append(molname)
        molWriter.write(scafmol)
    logging.info(f"{len(mols)} mols written to {molWriter}")
    return scafmols, legends


#############################################################################
def _mark_wildcard_attachments(core_smile: str):
    """
    Core generated by RGroupDecompose will mark wildcards
    with "[*:1]", "[*:2]", etc corresponding to matching R-groups.
    This function replaces these wildcards with just "*"
    """
    if not (isinstance(core_smile, str)):
        logging.debug(f"core_smile is not a string: {core_smile}")
        return core_smile
    return re.sub(r"\[\*:([0-9]+)\]", r"*", core_smile)


def _get_unique_mapping(df: pd.DataFrame, col: str):
    id_mapping = {}
    current_id = 0
    for c_item in df[col].unique():
        id_mapping[c_item] = current_id
        current_id += 1
    return id_mapping


def ScaffoldMap(mols, o_mol: str, o_scaf: str, odelim: str, oheader: bool):
    # want scaffolds + attachment points
    single_group_dfs = []
    mol_smiles = []
    for mol_id, mol in enumerate(mols):
        molname = mol.GetProp("_Name") if mol.HasProp("_Name") else ""
        logging.debug(f"{mol_id+1}. {molname}")
        scafmol = MurckoScaffold.GetScaffoldForMol(mol)

        mol_smile = MolToSmiles(mol)  # uses canonical SMILES
        scafmol_smiles = MolToSmiles(scafmol)
        if scafmol is None or len(scafmol_smiles) == 0:
            logging.warning(f"Failed to generate scaffold for {molname}")
            continue
        groups = {}
        if scafmol_smiles == mol_smile:
            groups["Core"] = [scafmol_smiles]
        else:
            # using RGroupDecompose because it provides attachment points for core (scaffold)
            groups, fails = rdRGroupDecomposition.RGroupDecompose(
                [scafmol], [mol], asRows=False, asSmiles=True
            )
            logging.debug(f"RGroupDecompose Failures: {fails}")
        single_group_df = PandasTools.RGroupDecompositionToFrame(
            groups, [mol], include_core=True
        )
        single_group_dfs.append(single_group_df)
        mol_smiles.append(mol_smile)

    # gather dfs
    group_df = pd.concat(single_group_dfs, ignore_index=True)
    group_df["Name"] = [
        m.GetProp("_Name") if m.HasProp("_Name") else "" for m in group_df["Mol"]
    ]
    group_df["Mol"] = mol_smiles
    group_df["Mol_ID"] = group_df.index  # assume given molecules are unique

    # get mapping
    group_df["Scaffold"] = group_df["Core"].map(_mark_wildcard_attachments)
    scaf_id_mapping = _get_unique_mapping(group_df, "Scaffold")
    group_df["Scaffold_ID"] = group_df["Scaffold"].map(scaf_id_mapping)
    scaf_id_df = pd.DataFrame.from_dict(
        scaf_id_mapping, orient="index", columns=["Scaffold_ID"]
    )
    scaf_id_df.reset_index(inplace=True, names=["Scaffold"])

    # re-order columns for readability
    cols = group_df.columns.tolist()
    rgroup_cols = [c for c in cols if c.startswith("R")]
    rgroup_cols.sort(key=lambda x: int(x[1:]))
    mol_id_df = group_df[["Name", "Mol", "Mol_ID", "Scaffold_ID", "Core"] + rgroup_cols]
    mol_id_df = mol_id_df.rename(columns={"Core": "Scaffold_R_Matched"})

    # save output
    scaf_id_df.to_csv(o_scaf, index=False, sep=odelim, header=oheader)
    mol_id_df.to_csv(o_mol, index=False, sep=odelim, header=oheader)
    return group_df


#############################################################################
def Mols2ScafNet(
    mols,
    brics=False,
    ofile: Optional[str] = None,
    odelimeter: str = ",",
    oheader: bool = False,
):
    if brics:
        params = rdScaffoldNetwork.BRICSScaffoldParams()
    else:
        params = rdScaffoldNetwork.ScaffoldNetworkParams()
        params.flattenChirality = True
        params.flattenIsotopes = True
        params.flattenKeepLargest = True
        params.includeGenericBondScaffolds = False
        params.includeGenericScaffolds = False
        params.includeScaffoldsWithAttachments = True
        params.includeScaffoldsWithoutAttachments = False
        params.keepOnlyFirstFragment = False
        params.pruneBeforeFragmenting = True

    attrs = [a for a in inspect.getmembers(params) if not (a[0].startswith("__"))]
    for a in attrs:
        logging.debug(f"{a[0]}: {a[1]}")

    for i, mol in enumerate(mols):
        molname = mol.GetProp("_Name") if mol.HasProp("_Name") else ""
        logging.debug(f"{i+1}. {molname}:")

    scafnet = rdScaffoldNetwork.CreateScaffoldNetwork(mols, params)
    if ofile is not None:
        write_scaffold_net(scafnet, ofile, odelimeter, oheader)
    logging.info(f"nodes: {len(scafnet.nodes)}; edges:{len(scafnet.edges)}")
    return scafnet


#############################################################################
def _get_node_edges(node_idx: int, edges: list[NetworkEdge]):
    """
    Get the edges which originate from a given node.
    """
    node_edges = []
    for e in edges:
        if e.beginIdx == node_idx:
            node_edges.append(e)
    return node_edges


def _construct_adjacency_list(scafnet) -> list[list]:
    n_nodes = len(scafnet.nodes)
    adjacency_list = list(
        map(lambda x: _get_node_edges(x, scafnet.edges), range(n_nodes))
    )
    return adjacency_list


def _get_fragment_map(init_edge: NetworkEdge, adj_list: list[list]) -> dict:
    """
    Perform BFS to generate a mapping from all nodes which are connected
    to init_edge.beginIdx (ie the original molecule) to their depth
    relative to the first molecule. first molecule has depth of 0.
    :param NetworkEdge init_edge: initial edge from input molecule.
    :param list[list] adj_list: adjacency list representation of a ScaffoldNet
    :return dict: mapping from node indices to their depth relative to
        init_edge.beginIdx
    """
    visited = {}
    fragment_nodes = {}  # map nodes to depth
    visited[init_edge] = True
    fragment_nodes[init_edge.beginIdx] = 0
    q = queue.Queue()
    q.put(init_edge)
    while not (q.empty()):
        edge = q.get()
        next_idx = edge.endIdx
        fragment_nodes[edge.endIdx] = fragment_nodes[edge.beginIdx] + 1
        next_edges = adj_list[next_idx]
        for e in next_edges:
            if e.type == EdgeType.Fragment and e not in visited:
                visited[e] = True
                q.put(e)
    return fragment_nodes


def write_hier_scafs(
    fragment_maps: list[dict],
    mol_indices: list[int],
    nodes: list,
    o_mol: str,
    o_scaf: str,
    odelimeter: str,
    oheader: bool,
):
    # idx == ids
    mol_writer, f_mol = get_csv_writer(o_mol, odelimeter)
    scaf_writer, f_scaf = get_csv_writer(o_scaf, odelimeter)
    if oheader:
        mol_writer.writerow(
            ["molecule_id", "mol_smiles", "scaffold_id", "scaffold_depth"]
        )
        scaf_writer.writerow(["scaffold_id", "scaffold_smiles"])
    seen_scafs = [False] * len(nodes)
    for frag_map, mol_idx in zip(fragment_maps, mol_indices):
        mol_smile = nodes[mol_idx]
        for scaf_idx in frag_map:
            if scaf_idx == mol_idx:
                continue
            scaf_smile = nodes[scaf_idx]
            scaf_depth = frag_map[scaf_idx]
            mol_writer.writerow([mol_idx, mol_smile, scaf_idx, scaf_depth])
            if not (seen_scafs[scaf_idx]):
                scaf_writer.writerow([scaf_idx, scaf_smile])
                seen_scafs[scaf_idx] = True
    close_file(f_mol)
    close_file(f_scaf)


def HierarchicalScaffolds(
    mols,
    brics: bool = False,
    o_mol: str = None,
    o_scaf: str = None,
    odelim: str = None,
    oheader: bool = False,
):
    scafnet = Mols2ScafNet(mols, brics)
    adjacency_list = _construct_adjacency_list(scafnet)
    mol_indices = []  # node indices of molecules in scafnet
    fragment_maps = []
    for e in scafnet.edges:
        if e.type == EdgeType.Initialize:
            fragment_map = _get_fragment_map(e, adjacency_list)
            fragment_maps.append(fragment_map)
            mol_indices.append(e.beginIdx)
    if o_mol is not None:
        write_hier_scafs(
            fragment_maps, mol_indices, scafnet.nodes, o_mol, o_scaf, odelim, oheader
        )
    return fragment_maps


#############################################################################
def ScafNet2Rings(scafnet, name, molWriter):
    """Output unique ringsystems only."""
    ringsmis = set()
    rings = []
    pat = rdkit.Chem.MolFromSmarts("*!@-*")  # Non-ring single bond.
    for smi in scafnet.nodes:
        logging.debug(f"node: {smi}")
        if smi not in ringsmis:
            ring = MolFromSmiles(smi)  # Ring-maybe.
            if len(smi) == 0 or len(ring.GetSubstructMatches(pat)) > 0:
                continue
            else:
                ringsmis.add(smi)
                rings.append(ring)
    rings_mol = MolFromSmiles(".".join(sorted(list(ringsmis))))
    rings_mol.SetProp("_Name", f"{name}_RINGS")
    molWriter.write(rings_mol)
    logging.info(f"{name}: rings: {len(ringsmis)}")
    return rings


#############################################################################
def DemoBM():
    scafmols = []
    for smi in util.DEMOSMIS:
        mol = MolFromSmiles(re.sub(r"\s.*$", "", smi))
        scafmol = MurckoScaffold.GetScaffoldForMol(mol) if mol else None
        scafmols.append(scafmol)
        smi_std = MolToSmiles(scafmol, isomericSmiles=False) if scafmol else None
        logging.info(f"{smi:>28s} >> {smi_std}")
    img = rdkit.Chem.Draw.MolsToGridImage(scafmols, molsPerRow=4)
    img.show()


#############################################################################
def DemoNetImg(scratchdir):
    fout = tempfile.NamedTemporaryFile(
        prefix=ensure_path_separator(scratchdir),
        suffix=".png",
        mode="w+b",
        delete=False,
    )
    ofile = fout.name
    fout.close()
    brics = True
    logging.debug(f"DemoNetImg({brics}, {fout.name})")
    smi = "Cc1onc(-c2c(F)cccc2Cl)c1C(=O)N[C@@H]1C(=O)N2[C@@H](C(=O)O)C(C)(C)S[C@H]12 flucloxacillin"
    mols = [MolFromSmiles(re.sub(r"\s.*$", "", smi))]
    scafnet = Mols2ScafNet(mols, False)
    logging.info(f"Scafnet nodes: {len(scafnet.nodes)}; edges: {len(scafnet.edges)}")
    # scafmols = [MolFromSmiles(m) for m in scafnet.nodes]
    scafmols = []
    for i, m in enumerate(scafnet.nodes[:]):
        logging.debug(f"{i+1}. MolFromSmiles({m})...")
        scafmols.append(MolFromSmiles(m))
    logging.info(f"Scafmols: {len(scafmols)}")
    img = Scafnet2Img(scafnet, ofile)
    img.show()


#############################################################################
def Scafnet2Img(scafnet, ofile, molsPerRow: int = 4):
    # title="RDKit_ScafNet:"+re.sub(r'^[^\s]*\s+(.*)$', r'\1', smi)) #How to add title?
    scafmols = [MolFromSmiles(m) for m in scafnet.nodes]
    img = rdkit.Chem.Draw.MolsToGridImage(
        scafmols,
        legends=[f"Idx: {i} , Counts: {c}" for i, c in enumerate(scafnet.counts)],
        molsPerRow=molsPerRow,
    )
    logging.debug(f"Writing scafnet PNG to: {ofile}")
    img.save(ofile, format="PNG")
    return img


#############################################################################
def DemoNetHtml(scratchdir):
    logging.debug(f"scratchdir: {scratchdir}")
    fout = tempfile.NamedTemporaryFile(
        prefix=ensure_path_separator(scratchdir),
        suffix=".html",
        mode="w+",
        delete=False,
    )
    ofile = fout.name
    logging.debug(f"ofile: {ofile}")
    logging.debug(f"DemoNetHtml({scratchdir}, {ofile})")
    demosmi = "Cc1onc(-c2c(F)cccc2Cl)c1C(=O)N[C@@H]1C(=O)N2[C@@H](C(=O)O)C(C)(C)S[C@H]12 flucloxacillin"
    mols = [MolFromSmiles(re.sub(r"\s.*$", "", demosmi))]
    scafnet = Mols2ScafNet(mols, False)
    logging.info(f"Scafnet nodes: {len(scafnet.nodes)}; edges: {len(scafnet.edges)}")
    g = Scafnet2Html(
        scafnet,
        "RDKit_ScafNet: " + re.sub(r"^[^\s]*\s+(.*)$", r"\1", demosmi),
        scratchdir,
        ofile,
    )
    fout.close()


#############################################################################
def Scafnet2Html(scafnet, scafname, scratchdir, ofile):
    logging.debug(f"pyvis.network.Network()...")
    g = pyvis.network.Network(
        notebook=False, height="800px", width="1000px", heading=scafname
    )
    logging.debug(f"pyvis.network.Network()... Done.")

    for i, smiles in enumerate(scafnet.nodes):
        logging.debug(f"{i+1}. util.moltosvg(rdkit.Chem.MolFromSmiles({smiles})...")
        svg = util.moltosvg(rdkit.Chem.MolFromSmiles(smiles))
        image_path = os.path.join(scratchdir, f"{i}.svg")
        with open(image_path, "w") as outf:
            outf.write(svg)
        logging.debug(f"g.add_node()...")
        g.add_node(
            i,
            shape="image",
            label=" ",
            image=image_path,
            title=f"SMILES: {smiles}\nIndex: {i}\nCounts: {scafnet.counts[i]}",
            size=60,
        )
        # Segmentation fault after last node.
    logging.debug(f"util.moltosvg()... Done.")
    for i, e in enumerate(scafnet.edges):
        logging.debug(f"{i+1}. g.add_edge()...")
        g.add_edge(e.beginIdx, e.endIdx, label=str(e.type))
    logging.debug(f"g.add_edge()... Done.")

    VisJS_options = {
        "edges": {"font": {"size": 20}},
        "nodes": {"font": {"color": "rgba(214,47,66,1)", "size": 16, "face": "tahoma"}},
        "physics": {
            "forceAtlas2Based": {
                "gravitationalConstant": -120,
                "springLength": 200,
                "avoidOverlap": 0.42,
            },
            "minVelocity": 0.75,
            "solver": "forceAtlas2Based",
        },
    }
    logging.debug(f"g.set_options()...")
    g.set_options(options=json.dumps(VisJS_options))
    if ofile:
        logging.info(f"Writing SCAFNET HTML to: {ofile}")
        # have to change working directory g.save_graph() only handles local files (for some reason)
        current_dir = os.getcwd()
        ofile_dir, ofile_name = os.path.dirname(ofile), os.path.basename(ofile)
        if ofile_dir != "":
            os.chdir(ofile_dir)
        g.save_graph(ofile_name)
        fix_pyvis_header_html(ofile)
        center_align_pyvis_html(ofile)
        # go back to original dir
        os.chdir(current_dir)
    return g


#############################################################################
